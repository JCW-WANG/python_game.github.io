<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>終極雙人亂鬥 | Ultimate Brawl</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Roboto:wght@400;700&display=swap');

        :root {
            --p1-color: #ff4757;
            --p2-color: #3742fa;
            --bg-color: #1e272e;
            --ui-bg: rgba(0, 0, 0, 0.8);
            --accent: #ffa502;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }
        
        body {
            background-color: #000;
            background-image: radial-gradient(circle at center, #2f3542 0%, #000 100%);
            color: white;
            font-family: 'Roboto', sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        /* 遊戲容器 */
        #game-container {
            position: relative;
            width: 960px;
            height: 540px;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            border: 2px solid #57606f;
            background: #111;
        }

        canvas { display: block; width: 100%; height: 100%; }

        /* UI 層 */
        .ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
        }

        /* 頂部 HUD */
        .hud {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            width: 100%;
        }

        .player-stat {
            width: 40%;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .bar-container {
            height: 20px;
            background: #333;
            margin-top: 5px;
            position: relative;
            transform: skewX(-20deg);
            overflow: hidden;
            border: 1px solid #fff;
        }

        .hp-bar { height: 100%; transition: width 0.1s; }
        .mp-bar { height: 6px; background: #eccc68; margin-top: 5px; width: 100%; transition: width 0.1s; box-shadow: 0 0 5px #eccc68; }

        .p1-stat .hp-bar { background: var(--p1-color); float: right; }
        .p2-stat .hp-bar { background: var(--p2-color); float: left; }
        .p1-stat { text-align: right; }
        .p2-stat { text-align: left; }

        .vs-logo {
            font-family: 'Black Ops One', cursive;
            font-size: 3rem;
            color: var(--accent);
            text-shadow: 0 0 10px var(--accent);
        }

        /* 角色選擇螢幕 */
        #menu-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(10, 10, 15, 0.95);
            display: flex; /* Flex handles visibility */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
            pointer-events: auto;
        }

        .char-select-container {
            display: flex;
            gap: 20px;
            margin: 30px 0;
        }

        .char-card {
            width: 120px;
            height: 180px;
            background: #2f3640;
            border: 2px solid #57606f;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .char-card:hover { transform: translateY(-10px); border-color: #fff; }
        .char-card.selected-p1 { box-shadow: 0 0 15px var(--p1-color); border-color: var(--p1-color); }
        .char-card.selected-p2 { box-shadow: 0 0 15px var(--p2-color); border-color: var(--p2-color); }
        
        .char-icon { width: 50px; height: 50px; margin-bottom: 10px; border-radius: 50%; }
        .char-name { font-weight: bold; font-size: 0.9rem; margin-bottom: 5px; }
        .char-type { font-size: 0.7rem; color: #aaa; }
        .char-desc { font-size: 0.65rem; color: #ccc; text-align: center; padding: 5px; }

        #status-text {
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: #ffda79;
        }

        .btn {
            padding: 10px 30px;
            font-size: 1.2rem;
            background: var(--accent);
            color: #000;
            border: none;
            cursor: pointer;
            font-weight: bold;
            clip-path: polygon(10% 0, 100% 0, 90% 100%, 0% 100%);
            transition: transform 0.2s;
        }
        .btn:hover { transform: scale(1.05); }
        .btn:disabled { background: #555; cursor: not-allowed; }

        /* 控制說明 */
        .controls-info {
            display: flex;
            width: 100%;
            justify-content: space-around;
            margin-top: 10px;
            color: #aaa;
            font-size: 0.9rem;
        }
        .key { display: inline-block; padding: 2px 6px; background: #333; border: 1px solid #555; border-radius: 4px; color: #fff; font-family: monospace; font-size: 0.8rem; }

        /* 遊戲結束 */
        #game-over-screen {
            display: none;
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
            pointer-events: auto;
        }
        #winner-text { font-size: 3rem; margin-bottom: 20px; font-weight: bold; text-transform: uppercase; }

    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>

        <div class="ui-layer" id="hud-layer" style="display: none;">
            <div class="hud">
                <div class="player-stat p1-stat">
                    <div id="p1-name-display">PLAYER 1</div>
                    <div class="bar-container"><div class="hp-bar" id="p1-hp"></div></div>
                    <div class="mp-bar" id="p1-mp" style="width: 100%"></div>
                </div>
                <div class="vs-logo">VS</div>
                <div class="player-stat p2-stat">
                    <div id="p2-name-display">PLAYER 2</div>
                    <div class="bar-container"><div class="hp-bar" id="p2-hp"></div></div>
                    <div class="mp-bar" id="p2-mp" style="width: 100%"></div>
                </div>
            </div>
        </div>

        <div id="menu-screen">
            <h1>選擇你的鬥士</h1>
            <div id="status-text">玩家 1 請選擇角色</div>
            
            <div class="char-select-container">
                </div>

            <button class="btn" id="start-btn" disabled>開始戰鬥</button>
            
            <div class="controls-info" style="margin-top: 40px;">
                <div>
                    <h3>玩家 1</h3>
                    <p>移動: <span class="key">W</span> <span class="key">A</span> <span class="key">D</span></p>
                    <p>防禦: <span class="key">S</span></p>
                    <p>攻擊: <span class="key">F</span> (連點)</p>
                    <p>技能: <span class="key">G</span> (耗能)</p>
                </div>
                <div>
                    <h3>玩家 2</h3>
                    <p>移動: <span class="key">↑</span> <span class="key">←</span> <span class="key">→</span></p>
                    <p>防禦: <span class="key">↓</span></p>
                    <p>攻擊: <span class="key">K</span> (連點)</p>
                    <p>技能: <span class="key">L</span> (耗能)</p>
                </div>
            </div>
        </div>

        <div id="game-over-screen">
            <div id="winner-text" style="color: #fff;">PLAYER 1 WINS</div>
            <button class="btn" onclick="location.reload()">重新選擇角色</button>
            <br>
            <button class="btn" id="rematch-btn" style="background: #2ecc71;">再戰一局</button>
        </div>
    </div>

    <script>
        /** * 遊戲核心配置與數據
         */
        const CHARACTERS = [
            {
                id: 'balanced',
                name: '烈焰劍士',
                type: '平衡型',
                desc: '各項能力平均，技能為發射火球。',
                color: '#ff4757',
                stats: { speed: 5, jump: 12, hp: 100, damage: 10, def: 0 },
                skillCost: 30,
                skillType: 'projectile' // 技能類型：飛行道具
            },
            {
                id: 'speed',
                name: '瞬影忍者',
                type: '速度型',
                desc: '移動極快，攻擊頻率高但血量少。技能為無敵衝刺。',
                color: '#2ed573',
                stats: { speed: 8, jump: 15, hp: 80, damage: 8, def: -2 },
                skillCost: 40,
                skillType: 'dash' // 技能類型：衝刺
            },
            {
                id: 'tank',
                name: '鋼鐵巨像',
                type: '坦克型',
                desc: '血厚防高但移動緩慢。技能為霸體護盾衝撞。',
                color: '#57606f',
                stats: { speed: 3, jump: 10, hp: 140, damage: 15, def: 5 },
                skillCost: 50,
                skillType: 'shield_bash' // 技能類型：護盾衝撞
            },
            {
                id: 'range',
                name: '秘法術士',
                type: '遠程型',
                desc: '近戰較弱。技能為召喚閃電領域。',
                color: '#a29bfe',
                stats: { speed: 6, jump: 11, hp: 90, damage: 6, def: -1 },
                skillCost: 45,
                skillType: 'aoe' // 技能類型：範圍攻擊
            },
            {
                id: 'lifesteal',
                name: '吸血伯爵',
                type: '特殊型',
                desc: '攻擊可以恢復少量生命。技能為鮮血爆發。',
                color: '#800000',
                stats: { speed: 5.5, jump: 13, hp: 95, damage: 9, def: 0 },
                skillCost: 35,
                skillType: 'lifesteal_burst' // 技能類型：吸血爆發
            }
        ];

        // 畫布設置
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 960;
        canvas.height = 540;

        // 全局變量
        let gameLoopId;
        let lastTime = 0;
        let gameState = 'MENU'; // MENU, PLAYING, END
        let p1Selection = null;
        let p2Selection = null;
        
        // 遊戲實體
        let player1, player2;
        let projectiles = [];
        let particles = [];
        let platforms = [
            { x: 0, y: 500, w: 960, h: 40 }, // 地面
            { x: 150, y: 350, w: 200, h: 20 },
            { x: 610, y: 350, w: 200, h: 20 },
            { x: 380, y: 200, w: 200, h: 20 }
        ];

        // 輸入控制
        const keys = {};
        window.addEventListener('keydown', e => keys[e.code] = true);
        window.addEventListener('keyup', e => keys[e.code] = false);

        /**
         * 類別：粒子系統 (特效)
         */
        class Particle {
            constructor(x, y, color, speed, size, life) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * speed;
                this.vy = (Math.random() - 0.5) * speed;
                this.color = color;
                this.size = size;
                this.life = life;
                this.maxLife = life;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life--;
            }
            draw(ctx) {
                ctx.globalAlpha = this.life / this.maxLife;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.globalAlpha = 1.0;
            }
        }
        
        class DamageText {
            constructor(x, y, text, color) {
                this.x = x;
                this.y = y;
                this.text = text;
                this.color = color;
                this.life = 60;
                this.vy = -1;
            }
            update() {
                this.y += this.vy;
                this.life--;
            }
            draw(ctx) {
                ctx.globalAlpha = Math.max(0, this.life / 60);
                ctx.fillStyle = this.color;
                ctx.font = "bold 20px Arial";
                ctx.strokeStyle = "black";
                ctx.lineWidth = 2;
                ctx.strokeText(this.text, this.x, this.y);
                ctx.fillText(this.text, this.x, this.y);
                ctx.globalAlpha = 1.0;
            }
        }

        /**
         * 類別：飛行道具 (技能)
         */
        class Projectile {
            constructor(owner, x, y, direction, type) {
                this.owner = owner;
                this.x = x;
                this.y = y;
                this.w = 30;
                this.h = 20;
                this.vx = direction * 12;
                this.type = type;
                this.life = 60; // 存在幀數
                this.color = owner.color;
            }

            update() {
                this.x += this.vx;
                this.life--;
                
                // 特效
                if (Math.random() < 0.5) {
                    particles.push(new Particle(this.x, this.y + 10, this.color, 2, 4, 20));
                }
            }

            draw(ctx) {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x + 15, this.y + 10, 10, 0, Math.PI*2);
                ctx.fill();
                // 拖尾
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                ctx.fillRect(this.x - (this.vx*2), this.y+5, 20, 10);
            }
        }

        /**
         * 類別：玩家
         */
        class Player {
            constructor(x, y, config, controls, isP1) {
                this.x = x;
                this.y = y;
                this.w = 40;
                this.h = 70;
                this.vx = 0;
                this.vy = 0;
                this.isP1 = isP1;
                
                // 屬性複製
                this.name = config.name;
                this.baseColor = config.color;
                this.speed = config.stats.speed;
                this.jumpPower = config.stats.jump;
                this.maxHp = config.stats.hp;
                this.hp = this.maxHp;
                this.damage = config.stats.damage;
                this.def = config.stats.def;
                this.skillType = config.skillType;
                this.skillCost = config.skillCost;
                this.mp = 100; // 能量值

                // 控制
                this.controls = controls;

                // 狀態
                this.grounded = false;
                this.facingRight = isP1;
                this.isAttacking = false;
                this.isBlocking = false;
                this.attackCooldown = 0;
                this.stunned = 0;
                this.invincible = 0; // 無敵幀
                this.dashTime = 0;
            }

            update() {
                // 受傷硬直 / 暈眩
                if (this.stunned > 0) {
                    this.stunned--;
                    this.vx *= 0.8; // 摩擦力
                    this.applyGravity();
                    this.checkCollision();
                    return;
                }

                // 無敵時間減少
                if (this.invincible > 0) this.invincible--;
                if (this.attackCooldown > 0) this.attackCooldown--;
                if (this.mp < 100) this.mp += 0.1; // 自動回能

                // 衝刺狀態 (忍者技能)
                if (this.dashTime > 0) {
                    this.x += this.facingRight ? 20 : -20;
                    this.dashTime--;
                    particles.push(new Particle(this.x, this.y + 35, '#fff', 5, 5, 10));
                    this.checkBounds();
                    return;
                }

                // 1. 移動邏輯
                this.vx = 0;
                this.isBlocking = false;

                if (keys[this.controls.left]) {
                    this.vx = -this.speed;
                    this.facingRight = false;
                }
                if (keys[this.controls.right]) {
                    this.vx = this.speed;
                    this.facingRight = true;
                }

                // 2. 跳躍
                if (keys[this.controls.up] && this.grounded) {
                    this.vy = -this.jumpPower;
                    this.grounded = false;
                    // 粒子特效
                    for(let i=0; i<5; i++) particles.push(new Particle(this.x+20, this.y+70, '#ccc', 3, 5, 20));
                }

                // 3. 防禦
                if (keys[this.controls.down] && this.grounded) {
                    this.vx = 0; // 防禦時不能移動
                    this.isBlocking = true;
                }

                // 4. 攻擊
                if (keys[this.controls.attack] && this.attackCooldown <= 0 && !this.isBlocking) {
                    this.performAttack();
                }

                // 5. 技能
                if (keys[this.controls.skill] && this.mp >= this.skillCost && this.attackCooldown <= 0) {
                    this.performSkill();
                }

                // 物理應用
                this.applyGravity();
                this.x += this.vx;
                this.y += this.vy;

                this.checkCollision();
                this.checkBounds();
            }

            applyGravity() {
                this.vy += 0.6; // 重力常數
            }

            checkCollision() {
                this.grounded = false;
                
                // 平台碰撞
                for (let p of platforms) {
                    // 簡單的AABB碰撞，只檢測腳下
                    if (this.vy >= 0 && // 只有下落時檢測
                        this.y + this.h - this.vy <= p.y + 10 && // 上一幀在平台上方
                        this.y + this.h >= p.y && // 當前幀穿過或接觸平台
                        this.x + this.w > p.x && 
                        this.x < p.x + p.w) {
                            
                        this.y = p.y - this.h;
                        this.vy = 0;
                        this.grounded = true;
                    }
                }
            }

            checkBounds() {
                if (this.x < 0) this.x = 0;
                if (this.x + this.w > canvas.width) this.x = canvas.width - this.w;
            }

            performAttack() {
                this.isAttacking = true;
                this.attackCooldown = 20;
                
                // 攻擊判定箱
                const range = 60;
                const hitX = this.facingRight ? this.x + this.w : this.x - range;
                const hitY = this.y + 10;
                const hitW = range;
                const hitH = 50;

                // 獲取對手
                const enemy = this.isP1 ? player2 : player1;

                // 檢測是否擊中
                if (checkRectCollide(hitX, hitY, hitW, hitH, enemy.x, enemy.y, enemy.w, enemy.h)) {
                    // 計算傷害
                    let dmg = this.damage;
                    let knockback = 10;

                    // 對手防禦邏輯
                    if (enemy.isBlocking) {
                        dmg = Math.max(1, dmg - enemy.def - 5); // 大幅減傷
                        knockback = 2; // 減少擊退
                        enemy.mp += 5; // 防禦成功回能
                        createDamageText(enemy.x, enemy.y - 20, "BLOCKED", "#fff");
                    } else {
                        // 正常命中
                        dmg = Math.max(1, dmg - (enemy.def/2));
                        createDamageText(enemy.x, enemy.y - 20, dmg.toFixed(0), "#ff0000");
                        enemy.stunned = 10; // 硬直
                        
                        // 特效
                        for(let i=0; i<10; i++) particles.push(new Particle(enemy.x + enemy.w/2, enemy.y + enemy.h/2, '#ff0000', 5, 4, 30));
                        
                        // 吸血鬼特性
                        if (this.skillType === 'lifesteal_burst') {
                            this.hp = Math.min(this.maxHp, this.hp + 2);
                        }
                    }

                    enemy.takeDamage(dmg);
                    // 擊退
                    enemy.vx = this.facingRight ? knockback : -knockback;
                    enemy.vy = -2;
                }
                
                // 攻擊動畫特效
                particles.push(new Particle(hitX + hitW/2, hitY + hitH/2, '#fff', 1, 30, 5));
                setTimeout(() => this.isAttacking = false, 150);
            }

            performSkill() {
                this.mp -= this.skillCost;
                this.attackCooldown = 30;
                createDamageText(this.x, this.y - 50, "SKILL!", "#ffff00");

                if (this.skillType === 'projectile') {
                    const dir = this.facingRight ? 1 : -1;
                    projectiles.push(new Projectile(this, this.facingRight ? this.x + 50 : this.x - 20, this.y + 20, dir));
                } 
                else if (this.skillType === 'dash') {
                    this.dashTime = 10; // 衝刺持續時間
                    this.invincible = 15;
                }
                else if (this.skillType === 'shield_bash') {
                    this.invincible = 30; // 霸體
                    this.damage *= 2; // 下一擊雙倍
                    this.vx = this.facingRight ? 15 : -15; // 小衝撞
                    setTimeout(() => this.damage /= 2, 500);
                }
                else if (this.skillType === 'aoe') {
                    const enemy = this.isP1 ? player2 : player1;
                    const dist = Math.abs((this.x + this.w/2) - (enemy.x + enemy.w/2));
                    if (dist < 200) {
                        enemy.takeDamage(15);
                        enemy.stunned = 40; // 強暈
                        enemy.vy = -10; // 擊飛
                        createDamageText(enemy.x, enemy.y - 40, "THUNDER!", "#a29bfe");
                        // 閃電特效
                        for(let i=0; i<20; i++) particles.push(new Particle(enemy.x + Math.random()*40, enemy.y, '#ffff00', 8, 3, 20));
                    }
                }
                else if (this.skillType === 'lifesteal_burst') {
                    // 周圍爆炸
                    const enemy = this.isP1 ? player2 : player1;
                    const dist = Math.abs(this.x - enemy.x);
                    if (dist < 100) {
                        enemy.takeDamage(10);
                        this.hp = Math.min(this.maxHp, this.hp + 15); // 大回血
                        enemy.vx = this.facingRight ? 15 : -15;
                        createDamageText(this.x, this.y - 40, "+HP", "#00ff00");
                    }
                }
            }

            takeDamage(amount) {
                if (this.invincible > 0) return;
                this.hp -= amount;
                if (this.hp <= 0) {
                    this.hp = 0;
                    endGame(this.isP1 ? "PLAYER 2" : "PLAYER 1");
                }
                updateHUD();
            }

            draw(ctx) {
                // 保存畫布狀態
                ctx.save();

                // 根據狀態改變透明度（如無敵）
                if (this.invincible > 0 && Math.floor(Date.now() / 50) % 2 === 0) {
                    ctx.globalAlpha = 0.5;
                }

                // 繪製身體
                ctx.fillStyle = this.baseColor;
                if (this.isBlocking) ctx.fillStyle = "#555"; // 防禦變灰
                
                ctx.fillRect(this.x, this.y, this.w, this.h);

                // 繪製眼睛（方向指示）
                ctx.fillStyle = "white";
                const eyeX = this.facingRight ? this.x + 25 : this.x + 5;
                ctx.fillRect(eyeX, this.y + 10, 10, 10);

                // 攻擊視覺效果
                if (this.isAttacking) {
                    ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
                    const atkX = this.facingRight ? this.x + this.w : this.x - 40;
                    ctx.fillRect(atkX, this.y + 10, 40, 50);
                }

                // 護盾特效
                if (this.isBlocking) {
                    ctx.strokeStyle = "#00a8ff";
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(this.x + this.w/2, this.y + this.h/2, 50, 0, Math.PI*2);
                    ctx.stroke();
                }

                ctx.restore();
            }
        }

        /**
         * 輔助函數
         */
        function checkRectCollide(x1, y1, w1, h1, x2, y2, w2, h2) {
            return x1 < x2 + w2 && x1 + w1 > x2 && y1 < y2 + h2 && y1 + h1 > y2;
        }

        function createDamageText(x, y, text, color) {
            particles.push(new DamageText(x, y, text, color));
        }

        function updateHUD() {
            // HP Bar
            const p1Pct = (player1.hp / player1.maxHp) * 100;
            const p2Pct = (player2.hp / player2.maxHp) * 100;
            document.getElementById('p1-hp').style.width = p1Pct + '%';
            document.getElementById('p2-hp').style.width = p2Pct + '%';

            // MP Bar
            document.getElementById('p1-mp').style.width = player1.mp + '%';
            document.getElementById('p2-mp').style.width = player2.mp + '%';
        }

        /**
         * 遊戲流程控制
         */
        
        // 1. 初始化選單
        function initMenu() {
            const container = document.querySelector('.char-select-container');
            container.innerHTML = '';
            
            CHARACTERS.forEach((char, index) => {
                const div = document.createElement('div');
                div.className = 'char-card';
                div.innerHTML = `
                    <div class="char-icon" style="background: ${char.color}"></div>
                    <div class="char-name">${char.name}</div>
                    <div class="char-type">${char.type}</div>
                    <div class="char-desc">${char.desc}</div>
                `;
                div.onclick = () => selectCharacter(index, div);
                container.appendChild(div);
            });
        }

        function selectCharacter(index, element) {
            const status = document.getElementById('status-text');
            const btn = document.getElementById('start-btn');

            if (p1Selection === null) {
                p1Selection = index;
                element.classList.add('selected-p1');
                status.innerText = "玩家 2 請選擇角色";
                status.style.color = "#3742fa";
            } else if (p2Selection === null) {
                // 允許重複選角，如果是同一個 element
                p2Selection = index;
                element.classList.add('selected-p2');
                status.innerText = "準備就緒！";
                status.style.color = "#2ed573";
                btn.disabled = false;
            }
        }

        document.getElementById('start-btn').addEventListener('click', startGame);
        document.getElementById('rematch-btn').addEventListener('click', () => {
            document.getElementById('game-over-screen').style.display = 'none';
            startGame();
        });

        // 2. 開始遊戲
        function startGame() {
            document.getElementById('menu-screen').style.display = 'none';
            document.getElementById('hud-layer').style.display = 'flex';
            gameState = 'PLAYING';

            // 初始化玩家
            const p1Config = CHARACTERS[p1Selection];
            const p2Config = CHARACTERS[p2Selection];

            document.getElementById('p1-name-display').innerText = p1Config.name;
            document.getElementById('p2-name-display').innerText = p2Config.name;

            // 控制器映射
            const p1Controls = { up: 'KeyW', down: 'KeyS', left: 'KeyA', right: 'KeyD', attack: 'KeyF', skill: 'KeyG' };
            const p2Controls = { up: 'ArrowUp', down: 'ArrowDown', left: 'ArrowLeft', right: 'ArrowRight', attack: 'KeyK', skill: 'KeyL' };

            player1 = new Player(100, 300, p1Config, p1Controls, true);
            player2 = new Player(800, 300, p2Config, p2Controls, false);
            
            projectiles = [];
            particles = [];

            updateHUD();

            if (!gameLoopId) {
                loop();
            }
        }

        // 3. 遊戲循環
        function loop() {
            const now = Date.now();
            const dt = now - lastTime;
            lastTime = now;

            if (gameState === 'PLAYING') {
                update();
                draw();
            }

            gameLoopId = requestAnimationFrame(loop);
        }

        function update() {
            player1.update();
            player2.update();

            // 飛行道具邏輯
            for (let i = projectiles.length - 1; i >= 0; i--) {
                let p = projectiles[i];
                p.update();

                // 移除超時或出界的
                if (p.life <= 0 || p.x < -100 || p.x > canvas.width + 100) {
                    projectiles.splice(i, 1);
                    continue;
                }

                // 擊中檢測
                const enemy = p.owner.isP1 ? player2 : player1;
                if (checkRectCollide(p.x, p.y, p.w, p.h, enemy.x, enemy.y, enemy.w, enemy.h)) {
                    // 造成傷害
                    let dmg = 8;
                    if (enemy.isBlocking) {
                        dmg = 1;
                        createDamageText(enemy.x, enemy.y, "BLOCK", "#fff");
                    } else {
                        enemy.stunned = 15;
                        enemy.vx = p.vx > 0 ? 5 : -5;
                        createDamageText(enemy.x, enemy.y, dmg.toString(), p.color);
                    }
                    enemy.takeDamage(dmg);
                    
                    // 撞擊特效
                    for(let k=0; k<8; k++) particles.push(new Particle(p.x, p.y, p.color, 4, 3, 15));
                    
                    projectiles.splice(i, 1);
                }
            }

            // 粒子特效更新
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                if (particles[i].life <= 0) particles.splice(i, 1);
            }
        }

        function draw() {
            // 清空畫布
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 繪製平台
            ctx.fillStyle = "#34495e";
            for (let p of platforms) {
                ctx.fillRect(p.x, p.y, p.w, p.h);
                // 平台邊框
                ctx.strokeStyle = "#7f8c8d";
                ctx.strokeRect(p.x, p.y, p.w, p.h);
            }

            // 繪製背景裝飾 (簡單網格)
            ctx.strokeStyle = "rgba(255,255,255,0.05)";
            ctx.beginPath();
            for(let i=0; i<canvas.width; i+=50) { ctx.moveTo(i,0); ctx.lineTo(i,canvas.height); }
            for(let i=0; i<canvas.height; i+=50) { ctx.moveTo(0,i); ctx.lineTo(canvas.width,i); }
            ctx.stroke();

            // 繪製物體
            player1.draw(ctx);
            player2.draw(ctx);

            projectiles.forEach(p => p.draw(ctx));
            particles.forEach(p => p.draw(ctx));
        }

        // 4. 結束遊戲
        function endGame(winnerName) {
            gameState = 'END';
            document.getElementById('game-over-screen').style.display = 'flex';
            document.getElementById('winner-text').innerText = `${winnerName} 獲勝！`;
        }

        // 啟動
        initMenu();

    </script>
</body>
</html>
